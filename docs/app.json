[{"name": "app.py", "content": "# --------------------------------------------\n# Imports at the top - PyShiny EXPRESS VERSION\n# --------------------------------------------\n\n# From shiny, import just reactive and render\nfrom shiny import reactive, render\n\n# From shiny.express, import just ui and inputs if needed\nfrom shiny.express import ui\n\nimport random\nfrom datetime import datetime\nfrom collections import deque\nimport pandas as pd\nimport plotly.express as px\nfrom shinywidgets import render_plotly\nfrom scipy import stats\nfrom shinyswatch import theme\n\n# --------------------------------------------\n# Import icons as you like\n# --------------------------------------------\n\n# https://fontawesome.com/v4/cheatsheet/\nfrom faicons import icon_svg\n\n# --------------------------------------------\n# Shiny EXPRESS VERSION\n# --------------------------------------------\n\n# --------------------------------------------\n# First, set a constant UPDATE INTERVAL for all live data\n# Constants are usually defined in uppercase letters\n# Use a type hint to make it clear that it's an integer (: int)\n# --------------------------------------------\n\nUPDATE_INTERVAL_SECS: int = 3\n\n# --------------------------------------------\n# Initialize a REACTIVE VALUE with a common data structure\n# The reactive value is used to store state (information)\n# Used by all the display components that show this live data.\n# This reactive value is a wrapper around a DEQUE of readings\n# --------------------------------------------\n\nDEQUE_SIZE: int = 5\nreactive_value_wrapper = reactive.value(deque(maxlen=DEQUE_SIZE))\n\n# --------------------------------------------\n# Initialize a REACTIVE CALC that all display components can call\n# to get the latest data and display it.\n# The calculation is invalidated every UPDATE_INTERVAL_SECS\n# to trigger updates.\n# It returns a tuple with everything needed to display the data.\n# Very easy to expand or modify.\n# --------------------------------------------\n\n\n@reactive.calc()\ndef reactive_calc_combined():\n    # Invalidate this calculation every UPDATE_INTERVAL_SECS to trigger updates\n    reactive.invalidate_later(UPDATE_INTERVAL_SECS)\n\n    # Data generation logic\n    temp = round(random.uniform(-18, -16), 1)\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    new_dictionary_entry = {\"temp\":temp, \"timestamp\":timestamp}\n\n    # get the deque and append the new entry\n    reactive_value_wrapper.get().append(new_dictionary_entry)\n\n    # Get a snapshot of the current deque for any further processing\n    deque_snapshot = reactive_value_wrapper.get()\n\n    # For Display: Convert deque to DataFrame for display\n    df = pd.DataFrame(deque_snapshot)\n\n    # For Display: Get the latest dictionary entry\n    latest_dictionary_entry = new_dictionary_entry\n\n    # Return a tuple with everything we need\n    # Every time we call this function, we'll get all these values\n    return deque_snapshot, df, latest_dictionary_entry\n\n# CSS for scrollable content\nstyle = \"\"\"\n<style>\n    body {\n        overflow-y: scroll;  /* Always show the vertical scrollbar */\n        padding: 20px;\n        height: 100vh;        /* Ensure the body takes full viewport height */\n    }\n    .shiny-main-content {\n        max-height: 80vh;     /* Limit the height of the main content */\n        overflow-y: scroll;   /* Always add vertical scrollbar if needed */\n    }\n</style>\n\"\"\"\n\n# Define the Shiny UI Page layout\n# Call the ui.page_opts() function\n# Set title to a string in quotes that will appear at the top\n# Set fillable to True to use the whole page width for the UI\nui.page_opts(\n     title=\"Melissa's PyShiny Express: Live Data Example\", \n     fillable=True, \n     theme=theme.darkly, \n     head=ui.HTML('<link rel=\"icon\" href=\"www/favicon.ico\" type=\"image/x-icon\">')\n     ) \n\n\n# Sidebar is typically used for user interaction/information\n# Note the with statement to create the sidebar followed by a colon\n# Everything in the sidebar is indented consistently\nwith ui.sidebar(bg=\"#301A4B\"):\n    ui.h2(\"Antarctic Explorer\", class_=\"text-center\")\n    ui.p(\n        \"A demonstration of real-time temperature readings in Antarctica.\",\n        class_=\"text-center\",\n    )\n    ui.hr()\n    ui.h6(\"Links:\")\n    ui.a(\n        \"GitHub Source\",\n        href=\"https://github.com/meldstonerogers/cintel-05-cintel\",\n        target=\"_blank\",\n    )\n    ui.a(\n        \"GitHub App\",\n        href=\"https://meldstonerogers.github.io/cintel-05-cintel-project/\",\n        target=\"_blank\",\n    )\n    ui.a(\"PyShiny\", href=\"https://shiny.posit.co/py/\", target=\"_blank\")\n    ui.a(\n        \"PyShiny Express\",\n        href=\"hhttps://shiny.posit.co/blog/posts/shiny-express/\",\n        target=\"_blank\",\n    )\n\n# In Shiny Express, everything not in the sidebar is in the main panel\n\nwith ui.layout_columns():\n    with ui.value_box(\n        showcase=icon_svg(\"snowflake\"),\n        theme=\"bg-gradient-blue-purple\",\n    ):\n\n        \"Current Temperature\"\n\n        @render.text\n        def display_temp():\n            \"\"\"Get the latest reading and return a temperature string\"\"\"\n            deque_snapshot, df, latest_dictionary_entry = reactive_calc_combined()\n            return f\"{latest_dictionary_entry['temp']} C\"\n\n        \"warmer than usual\"\n\n  \n\n    with ui.card(full_screen=True):\n        ui.card_header(\"Current Date and Time\")\n\n        @render.text\n        def display_time():\n            \"\"\"Get the latest reading and return a timestamp string\"\"\"\n            deque_snapshot, df, latest_dictionary_entry = reactive_calc_combined()\n            return f\"{latest_dictionary_entry['timestamp']}\"\n\nwith ui.layout_columns():\n        with ui.card(full_screen=True):\n            ui.card_header(\"Most Recent Readings\")\n\n            @render.data_frame\n            def display_df():\n                \"\"\"Get the latest reading and return a dataframe with current readings\"\"\"\n                deque_snapshot, df, latest_dictionary_entry = reactive_calc_combined()\n                pd.set_option('display.width', None)        # Use maximum width\n                return render.DataGrid( df,width=\"100%\")\n\n        with ui.value_box(\n                showcase=icon_svg(\"thermometer\"),\n                theme=\"bg-gradient-blue-purple\",\n            ):\n                \"Average Temperature Last 24 Hours\"\n                @render.text\n                def display_avgtemp():\n                        \"\"\"Get the average temperature for the last 24 hours.\"\"\"\n                        deque_snapshot, df, latest_dictionary_entry = reactive_calc_combined()\n\n                        # Ensure the DataFrame is not empty\n                        if not df.empty:\n                            # Convert the 'timestamp' column to datetime for filtering\n                            df[\"timestamp\"] = pd.to_datetime(df[\"timestamp\"])\n\n                            # Filter for the last 24 hours\n                            now = pd.Timestamp.now()\n                            last_24_hours = df[df[\"timestamp\"] >= now - pd.Timedelta(hours=24)]\n\n                            # Compute the average temperature if there are any readings\n                            if not last_24_hours.empty:\n                                avg_temp = last_24_hours[\"temp\"].mean()\n                                return f\"{avg_temp:.2f} \u00b0C\"\n                            else:\n                                return \"No temperature readings in the last 24 hours.\"\n\n                        return \"No data available.\"\n\n\nwith ui.card(full_scree=True):\n    ui.card_header(\"Chart with Current Temperature Trend\")\n    @render_plotly\n    def display_plot():\n        # Fetch from the reactive calc function\n        deque_snapshot, df, latest_dictionary_entry = reactive_calc_combined()\n\n        # Ensure the DataFrame is not empty before plotting\n        if not df.empty:\n            # Convert the 'timestamp' column to datetime for better plotting\n            df[\"timestamp\"] = pd.to_datetime(df[\"timestamp\"])\n\n            # Create scatter plot for readings\n            # pass in the df, the name of the x column, the name of the y column,\n            # and more\n        \n            fig = px.scatter(df,\n            x=\"timestamp\",\n            y=\"temp\",\n            title=\"Temperature Readings with Regression Line\",\n            labels={\"temp\": \"Temperature (\u00b0C)\", \"timestamp\": \"Time\"},\n            )\n\n            # Add Emoji symbols as \"text\" on the markers\n            fig.update_traces(\n                marker=dict(size=.5, color=\"dark blue\"),  # Marker customization\n                text=[\"\u2744\ufe0f\" for _ in range(len(df))],  # Snowflake emoji for all points\n                textposition=\"middle center\",  # Position of the emoji\n                mode=\"markers+text\"  # Show both marker and text\n            )\n            \n            # Linear regression - we need to get a list of the\n            # Independent variable x values (time) and the\n            # Dependent variable y values (temp)\n            # then, it's pretty easy using scipy.stats.linregress()\n\n            # For x let's generate a sequence of integers from 0 to len(df)\n            sequence = range(len(df))\n            x_vals = list(sequence)\n            y_vals = df[\"temp\"]\n\n            slope, intercept, r_value, p_value, std_err = stats.linregress(x_vals, y_vals)\n            df['best_fit_line'] = [slope * x + intercept for x in x_vals]\n\n            # Add the regression line to the figure\n            fig.add_scatter(x=df[\"timestamp\"], y=df['best_fit_line'], mode='lines', name='Regression Line', line=dict(color='darkblue', width=2))\n\n            # Update layout as needed to customize further\n            fig.update_layout(\n                xaxis_title=\"Time\",\n                yaxis_title=\"Temperature (\u00b0C)\",\n                plot_bgcolor='#F0F3F1',\n                paper_bgcolor='#434343',\n                font=dict(color='white'), \n                ),\n\n        return fig\n\nimport warnings\nwarnings.simplefilter(\"ignore\", category=RuntimeWarning)\n\n\n    \n\n\n\n\n", "type": "text"}]